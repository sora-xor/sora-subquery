type Asset @entity {
  id: ID!
  poolXYK: PoolXYK
  poolTBC: PoolTBC
  data: [AssetSnapshot!]! @derivedFrom(field: "asset")
}

type AssetPrice @jsonField {
  open: String!
  close: String!
  high: String!
  low: String!
}

type AssetVolume @jsonField {
  amount: String!
  amountUSD: String!
}

enum AssetSnapshotType {
  DEFAULT
  HOUR
  DAY
}

type AssetSnapshot @entity {
  id: ID!
  asset: Asset! @index #relation to Asset
  timestamp: Int!
  type: AssetSnapshotType!
  priceUSD: AssetPrice
  volume: AssetVolume
}

type PoolXYK @entity {
  id: ID!
  priceUSD: String
  strategicBonusApy: String
  baseAssetReserves: String!
  targetAssetReserves: String!
  multiplier: Int!
}

type PoolTBC @entity {
  id: ID!
  priceUSD: String
  collateralReserves: String!
}

type Account @entity {
  id: ID!
  latestHistoryElement: HistoryElement
}

type HistoryElement @entity {
  id: ID!
  blockHeight: BigInt!
  blockHash: String! @index
  module: String!
  method: String!
  address: String! @index
  networkFee: String!
  execution: ExecutionResult!
  timestamp: Int!
  data: HistoryElementDetails
}


type ExecutionResult @jsonField {
  success: Boolean!
  error: Error
}

type Error @jsonField {
  moduleErrorId: Int
  moduleErrorIndex: Int
  nonModuleErrorMessage: String
}

type HistoryElementDetails @jsonField {
  data: String # API is implemented by bypassing the scheme - `data` in all mappings is an object, not a String. See https://github.com/subquery/subql/issues/522.
}

type BurnedAssetsAmount @entity {
  id: ID!
  blockHeight: BigInt! @index
  blockHash: String!
  currencyId: String!
  balance: BigInt!
}

type RemintedAssetsAmount @entity {
  id: ID!
  blockHeight: BigInt! @index
  blockHash: String!
  currencyId: String!
  balance: BigInt!
}

type ClaimableReward @entity {
  id: ID!
  blockHeight: BigInt! @index
  blockHash: String!
  from: String!
  currencyId: String!
  balance: BigInt!
}

type ReferrerReward @entity {
	id: ID!
	referral: String! @index
	referrer: String!
	updated: Int!
	amount: BigInt!
}

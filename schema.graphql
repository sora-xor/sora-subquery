enum SnapshotType {
  DEFAULT
  HOUR
  DAY
  MONTH
}

type NetworkStats @entity {
  id: ID!
  totalFees: BigInt!
  totalAccounts: Int!
  totalTransactions: Int!
  totalBridgeIncomingTransactions: Int!
  totalBridgeOutgoingTransactions: Int!
}

type NetworkSnapshot @entity {
  id: ID!
  type: SnapshotType!
  timestamp: Int!
  accounts: Int!
  transactions: Int!
  fees: BigInt!
  liquidityUSD: String!
  volumeUSD: String!
  bridgeIncomingTransactions: Int!
  bridgeOutgoingTransactions: Int!
}

type UpdatesStream @entity {
  id: ID!
  block: Int!
  data: String! # stringified JSON
}

type Asset @entity {
  id: ID!
  data: [AssetSnapshot!]! @derivedFrom(field: "asset")
  poolXYK: [PoolXYK] @derivedFrom(field: "targetAsset")
  priceUSD: String!
  supply: BigInt!
  liquidity: BigInt! # locked in pairs (in tokens)
  liquidityUSD: Float # locked in pairs (in USD)
  priceChangeDay: Float
  priceChangeWeek: Float
  volumeDayUSD: Float
  volumeWeekUSD: Float
  velocity: Float # calculated in week
}

type AssetPrice @jsonField {
  open: String!
  close: String!
  high: String!
  low: String!
}

type AssetVolume @jsonField {
  amount: String!
  amountUSD: String!
}

type AssetSnapshot @entity {
  id: ID!
  asset: Asset! @index #relation to Asset
  timestamp: Int!
  type: SnapshotType!
  priceUSD: AssetPrice
  volume: AssetVolume
  liquidity: BigInt # locked in pairs (in tokens)
  supply: BigInt!
  mint: BigInt!
  burn: BigInt!
}

type PoolXYK @entity {
  id: ID!
  baseAsset: Asset!
  targetAsset: Asset!
  baseAssetReserves: BigInt!
  targetAssetReserves: BigInt!
  multiplier: Int!
  priceUSD: String
  strategicBonusApy: String
}

type Account @entity {
  id: ID!
  latestHistoryElement: HistoryElement
}

type HistoryElement @entity {
  id: ID!
  blockHeight: BigInt!
  blockHash: String! @index
  module: String!
  method: String!
  address: String! @index
  networkFee: String!
  execution: ExecutionResult!
  timestamp: Int!
  data: HistoryElementDetails
}

type ExecutionResult @jsonField {
  success: Boolean!
  error: Error
}

type Error @jsonField {
  moduleErrorId: Int
  moduleErrorIndex: Int
  nonModuleErrorMessage: String
}

type HistoryElementDetails @jsonField {
  data: String # API is implemented by bypassing the scheme - `data` in all mappings is an object, not a String. See https://github.com/subquery/subql/issues/522.
}

type ReferrerReward @entity {
	id: ID!
	referral: String! @index
	referrer: String!
	updated: Int!
	amount: BigInt!
}
